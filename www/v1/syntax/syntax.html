<!DOCTYPE html>
<html lang="en-gb">
<head>
  <meta charset="us-ascii">
  <title>egg Syntax</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700|Roboto+Slab:400,700" rel="stylesheet">
  <style>
    body {
      font-family: "Roboto Slab", serif;
      color: hsl(30,100%,9%);
      margin: 0 24px;
    }
    pre, code, .egg, .fixed, .diagram, .railroad {
      font-family: "Roboto Mono", monospace;
    }
    header, h1, h2, h3, h4, footer {
      border: 1px solid hsl(30,100%,39%);
      border-radius: 1ex;
      margin: 16px -16px;
      padding: 0.5ex 1ex;
      background-color: hsl(30,100%,93%);
      box-shadow: 3px 3px 2px hsla(30,100%,39%,25%);
    }
    header {
      font-size: 250%;
      font-weight: bold;
      overflow: hidden;
    }
    header > a > img {
      height: 1.5em;
      float: right;
    }
    code {
      background-color: hsl(30,100%,93%);
      padding: 0 0.5ex;
    }
    table {
      border: 1px solid hsl(30,100%,39%);
      border-radius: 1ex;
      border-spacing: 2px;
      background-color: hsl(30,100%,96%);
      margin: 1em 0 1em 24px;
      padding: 0.5ex;
    }
    tbody tr {
      background-color: hsl(30,100%,93%);
    }
    tbody tr:nth-child(2n+1) {
      background-color: hsl(30,100%,99%);
    }
    th {
      vertical-align: bottom;
    }
    th, td {
      padding: 0 1ex;
      text-align: left;
    }
    a {
      color: hsl(30,100%,39%);
      text-decoration: none;
    }
    .railroad, .diagram {
      font-size: 125%;
    }
    .railroad, .diagram, table {
      filter: drop-shadow(3px 3px 2px hsl(30,100%,25%,25%));
    }
    #ascii, #bottlecaps, .code {
      font-size: 75%;
    }
    #ascii {
      font-weight: bold;
    }
    #ascii .rule {
      background-color: rgba(0,0,255,0.1);
      color: rgb(0,0,255);
      border-radius: 1em;
      line-height: 150%;
    }
    #ascii .token {
      background-color: rgba(0,255,0,0.2);
      color: rgb(0,128,0);
      border-radius: 1ex;
      line-height: 150%;
    }
    #ascii .terminal {
      background-color: rgba(255,0,0,0.2);
      color: rgb(128,0,0);
      line-height: 150%;
    }
    #ascii pre {
      margin: 0;
      border: none;
    }
    #bottlecaps {
      white-space: pre;
    }
    .toc-2 {
      margin-left: 1em;
    }
    .toc-3 {
      margin-left: 2em;
    }
    .toc-4 {
      margin-left: 3em;
    }
    .toc-5 {
      margin-left: 4em;
    }
    .toc-6 {
      margin-left: 5em;
    }
    .code {
      border: 1px solid hsl(30,100%,39%);
      border-radius: 1ex;
      background-color: hsl(30,100%,96%);
      box-shadow: 3px 3px 2px hsla(30,100%,39%,25%);
      margin: 1em 0 1em 24px;
      padding: 1em;
      width: fit-content;
    }
    .code-comment {
      color: hsl(132,100%,33%);
      font-style: italic;
    }
    .code-string {
      color: hsl(235,100%,33%);
    }
    .code-identifier {
      color: hsl(30,100%,33%);
    }
    .code-keyword {
      color: hsl(287,100%,33%);
      font-weight: bold;
    }
    .link {
      visibility: hidden;
    }
    .icon {
      height: 0.7em;
    }
    .collapsible {
      border: 1px solid hsl(30,100%,39%);
      border-radius: 1ex;
      background-color: hsl(30,100%,96%);
      box-shadow: 3px 3px 2px hsla(30,100%,39%,25%);
      margin: 1em 0 1em 24px;
      width: fit-content;
    }
    .collapsible > a {
      position: absolute;
      left: 8px;
      width: 40px;
      padding-top: 0.3ex;
    }
    .collapsible > a > img {
      width: 36px;
      visibility: hidden;
    }
    .collapsible > div:nth-child(2) {
      font-weight: bold;
      margin: 0.5ex 1em;
    }
    .collapsible > div:last-child {
      border-top: 1px solid hsl(30,100%,39%);
      padding: 0.5em 1em;
    }
    .egg {
      font-weight: normal;
      font-style: italic;
    }
    @media screen {
      body {
        background-color: hsl(30,100%,99%);
      }
      h1:hover .link, h2:hover .link, h3:hover .link, h4:hover .link, h5:hover .link, h6:hover .link {
        visibility: visible;
      }
      :target {
        animation: flash ease-in-out 0.25s alternate 2;
      }
      @keyframes flash {
        from { background-color: hsl(30,100%,93%); }
        to { background-color: hsl(30,100%,66%); }
      }
      .collapsible:hover img {
        visibility: visible;
      }
      .collapsible > div:last-child {
        display: none;
      }
    }
    @media print {
      pre {
        page-break-inside: avoid;
      }
    }
  </style>
  <script src="syntax.js"></script>
  <script src="bnf.js"></script>
</head>
<body>
  <header id="top">The <span class="egg">egg</span> Programming Language Syntax<a href="#top"><img src="../../egg.png" /></a></header>
  This document contains details of the syntax of the <span class="egg">egg</span> programming language.
  It is not designed as a resource for learning the language from scratch, but programmers fluent in other computer languages may find it useful as an overview of <span class="egg">egg</span>.
  <div class="collapsible">
    <div>Table of Contents</div>
    <div id="toc"></div>
  </div>
  <h1>Informal Syntax</h1>
  This section gives an informal overview of the syntax.
  <h2><span class="egg">egg</span> Railroad Diagrams</h2>
  A <a href="https://en.wikipedia.org/wiki/Syntax_diagram">railroad diagram</a> is a visual representation of a syntax specification.
  <span class="egg">egg</span> uses a particular style of railroad diagram which we describe here.
  Each rule is enclosed in a cyan box with the rule name on a tab in the top-left.
  A green track flows into the rule from the left, passes through the rule box and exits to the right.
  In the example below, the rule "<i>greeting</i>" is defined simply as the token "<code>hello</code>", represented by a purple box:
  <div class="diagram">{ "greeting": {"token": "hello", "inline": false, "left": 1, "right": 1} }</div>
  Note that tokens are indivisible and case-sensitive.
  The above rule would match the text "<code>hello</code>" but not "<code>hell o</code>" or "<code>Hello</code>".
  We can change the rule to accept a <i>sequence</i> of tokens, optionally separated by whitespace (including newlines):
  <div class="diagram">{ "greeting": {"sequence": [{"token": "hello"}, {"token": "world"}], "inline": false, "left": 1, "right": 1} }</div>
  We can also introduce <i>choices</i> by putting junctions in the tracks.
  The following rule accepts either "<code>hello</code>" or "<code>hi</code>"; but exactly one of them must be specified:
  <div class="diagram">{ "greeting": {"choice": [{"token": "hello"}, {"token": "hi"}], "inline": false} }</div>
  In the following rule, "<code>hello</code>" is compulsory, but "<code>world</code>" is <i>optional</i> (however, it must follow "<code>hello</code>"):
  <div class="diagram">{ "greeting": {"sequence": [{"token": "hello"}, {"zeroOrOne": {"token": "world"}}], "inline": false, "left": 1} }</div>
  We can introduce <i>repetition</i> by making the tracks loops back on the themselves.
  The following rule matches "<code>hello</code>" followed by one or more question marks:
  <div class="diagram">{ "greeting": {"sequence": [{"token": "hello"}, {"oneOrMore": {"token": "?"}}], "inline": false, "left": 1, "right": 1} }</div>
  By comparison, this rule matches "<code>hello</code>" followed by zero or more question marks:
  <div class="diagram">{ "greeting": {"sequence": [{"token": "hello"}, {"zeroOrMore": {"token": "?"}}], "inline": false, "left": 1, "right": 1} }</div>
  Sometimes, the items in the rule are not tokens, but some other kind of <i>terminal</i>, described informally elsewhere.
  In this case, the terminal is drawn in a blue hexagon:
  <div class="diagram">{ "name": {"oneOrMore": {"terminal": "letter"}, "inline": false, "left": 1, "right": 1} }</div>
  Finally, rules can be composed by referring to them within other rules using brown ovals:
  <div class="diagram">{ "greeting-personal": {"sequence": [{"rule": "greeting"}, {"rule": "name"}], "inline": false, "left": 1, "right": 1} }</div>
  <h2><span class="egg">egg</span> Syntax</h2>
  <span class="egg">egg</span> programs are split up into distinct parts, named "modules".
  The source code for each module is typically stored in a separate text file.
  <h3>Comments</h3>
  Comments in <span class="egg">egg</span> source code can either be a single line or multiple lines:
  <div class="diagram">{ "comment": {"choice": [{"sequence": [{"token": "//"}, {"zeroOrMore": {"terminal": "any-character-except-newline"} }, {"terminal": "newline"}]}, {"sequence": [{"token": "/*"}, {"zeroOrMore": {"terminal": "any-character"}}, {"token": "*/"}]}] } }</div>
  For example:
  <pre class="code">// This is a comment until the end of the line

/* This is a comment
    that's split over
     multiple lines */</pre>
  Comments can appear anywhere where whitespace is acceptable.
  <h3>Modules</h3>
  Modules contain one or more statements.
  Each statement may be preceded one or more attributes (<a>attributes</a>).
  <div class="railroad">module</div>
  <h3>Statements</h3>
  A statement is one of the following:
  <ul>
    <li>a compound statement consisting of zero or more statements within a pair of curly braces,</li>
    <li>a simple statement with a trailing semicolon,</li>
    <li>a function definition, or</li>
    <li>a flow control statement.</li>
  </ul>
  That is
  <div class="railroad">statement</div>
  <h4>Simple Statement</h4>
  A simple statement is an action, a type definition or a variable definition:
  <div class="railroad">statement-simple</div>
  <h4>Action Statement</h4>
  An action is an assignment, an increment/decrement or a function call statement:
  <div class="railroad">statement-action</div>
  <h4>Assignment Statement</h4>
  Assignments may simply store a value in a target, such as:
  <pre class="code">target = value;</pre>
  or they may incorporate a binary operator (<a>binary-operator</a>) to modify the target:
  <pre class="code">target += value;</pre>
  The latter is equivalent to the following (except that the target expression is evaluated only once):
  <pre class="code">target = target + value;</pre>
  Assignment targets are one of the following:
  <ul>
    <li>a variable,</li>
    <li>a dereferenced pointer expression,</li>
    <li>an indexed expression, or</li>
    <li>a property of an expression.</li>
  </ul>
  That is
  <div class="railroad">assignment-target</div>
  For example:
  <pre class="code">int a;
a = 123; // Assign to variable

int* b = &amp;a;
*b = 321; // Assign via pointer

int[] c = [9, 2, 3];
c[0] = 1; // Assign to indexed element

object d = {};
d.field = 321; // Assign to property</pre>
  <h4>Increment/Decrement Statement</h4>
  In <span class="egg">egg</span>, increments and decrements are statements (not expressions) and must use the prefix unary operators:
  <pre class="code">++target;
--target;</pre>
  The statements above are analogous to:
  <pre class="code">target = target + 1;
target = target - 1;</pre>
  They are included in the language so that classic index-based for-loop idioms can be used:
  <pre class="code">for (i = 0; i &lt; 100; ++i) {
  // Loops from 0 to 99 inclusive
}</pre>
  <h3>Flow Control</h3>
  Flow control statements affect the order of execution of other statements.
  <h4>If Statement</h4>
  Like most computer languages, <code>if</code> statements can have optional <code>else</code> clauses:
  <div class="railroad">statement-if</div>
  Note that the curly braces are compulsory, <i>except</i> when an <code>else</code> clause is immediately followed by another <code>if</code> statement:
  <pre class="code">if (condition1) {
  // Do this only if 'condition1' is true
}

if (condition2) {
  // Do this only if 'condition2' is true
} else {
  // Do this only if 'condition2' is false
}

if (condition3) {
  // Do this only if 'condition3' is true
} else if (condition4) {
  // Do this only if 'condition3' is false but 'condition4' is true
} else {
  // Do this if both 'condition3' and 'condition4' are false
}</pre>
  <h4>Switch Statement</h4>
  The <code>switch</code> statement acts like a series of <code>if</code> statements:
  <div class="railroad">statement-switch</div>
  Unlike some other programming languages, expressions in the <code>case</code> statements need not be constant.
  Each <code>case</code>/<code>default</code> clause must end in a <code>break</code>, <code>continue</code>, <code>return</code> or <code>throw</code> statement.
  A <code>break</code> statement breaks out of the <code>switch</code> statement.
  A <code>continue</code> statement continues execution at the beginning of the next (or first) <code>case</code>/<code>default</code> clause.
  For example:
  <pre class="code">switch (greeting) {
  case "hello":
  case "hi":
    english = true;
    continue;
  case greetingInLocalLanguage():
    print("greeting is ", greeting, "\n");
    break;
  default:
    throw "unknown greeting";
}</pre>
  <h4>While Loop</h4>
  The <code>while</code> loop executes the statements within its curly brace block whilst a condition is true:
  <div class="railroad">statement-while</div>
  For example:
  <pre class="code">// Find the factorial of n
var factorial = 1;
while (n > 1) {
  factorial *= n;
  --n;
}</pre>
  You can break out of the loop with a <code>break</code> statement or immediately go to the next iteration with <code>continue</code>.
  <pre class="code">while (condition1) {
  if (condition2) {
    break;
  }
  if (condition3) {
    continue;
  }
  doSomething();
  // 'continue' jumps to here
}
// 'break' jumps to here
doSomethingAfter();</pre>
  <h4>Do Loop</h4>
  The <code>do</code> loop is similar to the <code>while</code> loop, but executes the statements at least once:
  <div class="railroad">statement-do</div>
  For example:
  <pre class="code">// Print 10 to 1 in descending order
var i = 10;
do {
  print(i, "\n");
  --i;
} while (i > 0);</pre>
  You can break out of the loop with a <code>break</code> statement or immediately go to the next iteration with <code>continue</code>.
  <pre class="code">do {
  if (condition1) {
    break;
  }
  if (condition2) {
    continue;
  }
  doSomething();
  // 'continue' jumps to here
} while (condition3);
// 'break' jumps to here
doSomethingAfter();</pre><h4>For Loop</h4>
  The <code>for</code> loop comes in two flavours.
  The vanilla <code>for</code> loop takes an <i>initialization</i> statement, a <i>condition</i>, an <i>advance</i> statement and a block of statements within curly braces.
  <div class="railroad">statement-for</div>
  For example:
  <pre class="code">// Sum the integers up to and including 'n'
var sum = 0;
for (var i = 1; i &lt;= n; ++i) {
  sum += i;
}</pre>
  The second flavour of the <code>for</code> loop is "foreach".
  It loops over all the elements in an expression.
  <div class="railroad">statement-foreach</div>
  For example:
  <pre class="code">// Sum the elements of an array
var array = [1, 2, 3, 5, 8, 13, 21];
var sum = 0;
for (var i : array) {
  sum += i;
}</pre>
  In both flavours of <code>for</code>, you can break out of the loop with a <code>break</code> statement or go to the next iteration with <code>continue</code>.
  <pre class="code">for (var i = 0; i &lt; n; ++i) {
  if (condition1) {
    break;
  }
  if (condition2) {
    continue;
  }
  doSomething();
  // 'continue' jumps to here
}
// 'break' jumps to here
doSomethingAfter();</pre><h4>Break Statement</h4>
  A <code>break</code> statement prematurely breaks out of a <code>while</code>, <code>do</code> or <code>for</code> loop.
  <div class="railroad">statement-break</div>
  For example:
  <pre class="code">// Sum the elements until the total is greater than twenty
var array = [1, 2, 3, 5, 8, 13, 21];
var sum = 0;
for (var i : array) {
  sum += i;
  if (sum > 20) {
    break;
  }
}
// 'break' jumps to here</pre>
  It is also used to break out from a <code>switch</code> statement.
  <h4>Continue Statement</h4>
  A <code>continue</code> statement immediately starts the next iteration of a <code>while</code>, <code>do</code> or <code>for</code> loop.
  <div class="railroad">statement-continue</div>
  It can also be used in a <code>switch</code> statement to continue execution at the beginning of the next (or first) <code>case</code>/<code>default</code> clause.
  <h4>Throw Statement</h4>
  A <code>throw</code> statement raises an exception.
  <div class="railroad">statement-throw</div>
  Execution continues at the most recent, active <code>catch</code> clause that matches the type of the expression:
  For example:
  <pre class="code">float safeSqrt(float x) {
  if (x &lt; 0) {
    throw "attempt to take the square root of a negative number";
  }
  return math.sqrt(x);
}

float y;
try {
  y = safeSqrt(-1);
} catch (any exception) {
  print("exception thrown: ", exception);
  // Handle the problem here
}</pre>
  Within a <code>catch</code> clause, a <code>throw</code> statement without an expression re-throws the original exception:
  <pre class="code">try {
  y = safeSqrt(-1);
} catch (any exception) {
  print("exception thrown: ", exception);
  throw; // Rethrow the exception
}</pre>
  <h4>Try Statement</h4>
  The <code>try</code> statement comes in two flavours.
  A <code>try</code> statement without a <code>finally</code> clause must have at least one <code>catch</code> clause:
  <div class="railroad">statement-try</div>
  The first <code>catch</code> clause, if any, that matches the type of the exception thrown within the <code>try</code> block, is executed.
  <div class="railroad">statement-catch</div>
  For example:
  <pre class="code">try {
  runSomethingThatMightFail();
} catch (ArithmeticException exception) {
  reportProblem("arithmetic", exception);
} catch (any exception) {
  reportProblem("something else", exception);
}</pre>
  In <code>try</code> statements with a <code>finally</code> clause, <code>catch</code> clauses are optional:
  <div class="railroad">statement-try-finally</div>
  The <code>finally</code> clause is always executed, whether or not an exception is thrown or caught.
  <pre class="code">var resource = acquireResource();
try {
  processResource(resource);
} finally {
  // Guaranteed to be called
  releaseResource(resource);
}</pre>
  <h4>Return Statement</h4>
  For functions defined to return a value, the <code>return</code> statement ends the function, returning the expression to the caller:
  <div class="railroad">statement-return</div>
  For example:
  <pre class="code">double computeSquare(double x) {
  // Return the square of 'x'
  return x * x;
}</pre>
  For functions with no return value, the <code>return</code> statement without an expression is used:
  <pre class="code">void squareIt(double* p) {
  // Squares the value pointed to by 'p'
  *p *= *p;
  return;
}</pre>
  <h4>Yield Statement</h4>
  In <i>generator</i> functions, <code>yield</code> statements return values to the caller without terminating the function:
  <div class="railroad">statement-yield</div>
  For example:
  <pre class="code">int! fibonacci(int a, int b) {
  // Compute an infinite series of Fibonacci numbers
  for (;;) {
    yield a;
    var c = a + b;
    a = b;
    b = c;
  }
}</pre>
  If the <code>yield ...</code> form of the statement is used, all values in the expression are yielded, one after another:
  <pre class="code">any! prefix(any head, any! tail) {
  // Yield 'head' then all the values in 'tail'
  yield  head;
  yield ...tail;
}</pre>
  <h3>Definitions</h3>
  Definitions introduce new identifiers to the current scope.
  <h4>Identifiers</h4>
  There are four kinds of identifiers: <i>identifier-attribute</i>, <i>identifier-property</i>, <i>identifier-type</i> and <i>identifier-variable</i>.
  They are all synonyms for <i>identifier</i>:
  <div class="railroad">identifier</div>
  Identifiers must begin with an ASCII letter ("<code>A</code>" to "<code>Z</code>" or "<code>a</code>" to "<code>z</code>") or an underscore ("<code>_</code>").
  Subsequent characters may be ASCII letters, underscores, digits ("<code>0</code>" to "<code>9</code>") or non-ASCII unicode.
  Identifiers are case-sensitive.
  Valid identifiers include:
  <ul>
    <li><code>hello</code></li>
    <li><code>HelloWorld</code></li>
    <li><code>hello_world</code></li>
    <li><code>_</code></li>
    <li><code>_hello</code></li>
    <li><code>hello123</code></li>
    <li><code>ol&aacute;</code> (trailing accented letters are permitted)</li>
  </ul>
  Invalid identifiers include:
  <ul>
    <li><code>123hello</code> (must not start with a digit)</li>
    <li><code>hello world</code> (must not contain spaces)</li>
    <li><code>hello-world</code> (must not contain ASCII non-alphamerics such as a hyphen)</li>
    <li><code>&gamma;&epsilon;&iota;&#940;_&sigma;&omicron;&upsilon;</code> (must not start with a non-ASCII character)</li>
  </ul>
  <h4>Function Definition</h4>
  Function definitions are divided into four sections:
  <ol>
    <li>The return type</li>
    <li>The function name (variable identifier)</li>
    <li>The parameter list inside parentheses</li>
    <li>The statement block inside curly braces</li>
  </ol>
  All four sections must be given:
  <div class="railroad">definition-function</div>
  The return type is specified as a type expression.
  The return type <code>void</code> is used for functions that do not return a value.
  For example:
  <pre class="code">void greet() {
  print("hello\n");
}</pre>
  The function name ("<code>greet</code>" in the example above) introduces a new variable to the current scope.
  The variable is initialized with a first-class entity that represents the function.
  For example:
  <pre class="code">float square(float x) {
  return x * x;
}
print(square.name, "\n"); // Prints 'square'
print(square(9), "\n"); // Prints '81'</pre>
  The parameter list contains the types and names of the function parameters, if any, separated by commas:
  <div class="railroad">definition-function-parameter</div>
  The only permitted default value for optional parameters is <code>null</code>.
  For example:
  <pre class="code">float logarithm(float x, float? base = null) {
  if (base == null) {
    return math.ln(x);
  }
  return math.ln(x) / math.ln(base);
}</pre>
  Two kinds of <i>variadic parameter</i> are supported.
  <i>Name-based variadic parameters</i> are passed in as an object whose properties are the named parameters supplied by the caller.
  For example:
  <pre class="code">float divide(...object vargs) {
  return vargs.x / vargs.y;
}
print(divide(x: 3, y: 4, z: 6), "\n"); // Prints '0.75' (z is ignored)</pre>
  In the other kind, <i>index-based variadic parameters</i> are passed in to the function as an array, in the order supplied by the caller.
  For example:
  <pre class="code">int sum(...int[] vargs) {
  int total = 0;
  for (var element : vargs) {
    total += element;
  }
  return total;
}
print(sum(3, 1, 4, 1, 5, 9), "\n"); // Prints '23'</pre>
  <h4>Generator Function Definition</h4>
  Generator function definitions look like function definitions except they have at least one <code>yield</code> statement within the statement block.
  <h4>Type Definition</h4>
  Type definitions introduce new identifiers that are synonymous with an arbitrary type.
  <div class="railroad">definition-type</div>
  For example:
  <pre class="code">type Number = int|float;
Number n; // Synonymous with 'int|float n'</pre>
  <i>Generic type</i> definitions can be parameterized by one or more other types:
  <pre class="code">type Dictionary&lt;K, V&gt; = {
  properties: {
    add: bool(K key, V value),
    remove: bool(K key),
    find: V?(K key)
  }
};</pre>
  <h4>Variable Definition</h4>
  Variables can either be defined with a specific type, or can have their type inferred.
  <div class="railroad">definition-variable</div>
  If an explicit type is given, but no value, the variable is initially undefined:
  <pre class="code">int i; // 'i' is undefined
i = 10; // 'i' now has the value ten</pre>
  If an initial value is give, the expression type should be appropriate:
  <pre class="code">int i = 10; // 'i' has the value ten</pre>
  If the <code>var</code> keyword is used, the type is inferred from the expression:
  <pre class="code">var i = 4;     // 'i' is an 'int' with value four
var j = i * i; // 'j' is an 'int' with value sixteen</pre>
  However, the inferred type is never nullable.
  To permit null values, use <code>var?</code>:
  <pre class="code">float? root(float x) {
  if (x &lt; 0) {
    return null;
  }
  return math.sqrt(x);
}

var x = root(4);   // 'x' is a 'float' with value two
var? y = root(-4); // 'y' is a 'float?' with value null
var z = root(-4);  // This causes a runtime error</pre>
  <h3>Literals</h3>
  Literals represent fixed values.
  <div class="railroad">literal</div>
  The literal value <code>null</code> and the Boolean literal values <code>false</code> and <code>true</code> each have their own keywords.
  <h4>Integer Literal</h4>
  Integer literals are presented by a sequence of decimal digits, optionally prefix by a sign.
  <div class="railroad">literal-int</div>
  Examples of valid integer literals include <code>0</code>, <code>123</code>, <code>-123</code> and <code>+123</code>.
  Note that <span class="egg">egg</span> only support denary numeric literals; octal and hexadecimal are not supported.
  <h4>Floating-Point Literal</h4>
  Floating-point literals are similar but contain a compulsory decimal point followed by at least one digit.
  There may also be an optional, trailing, signed integer exponent.
  <div class="railroad">literal-float</div>
  Examples of valid integer literals include <code>0.0</code>, <code>-123.45</code>, <code>+1.0e-9</code> and <code>0.01e+050</code>.
  <h4>String Literal</h4>
  String literals are surrounded by double quote characters.
  They may contain any valid Unicode character.
  <div class="railroad">literal-string</div>
  Special characters within the string may be <i>escaped</i> using backslash sequences:
  <table>
    <thead>
      <tr><th>Sequence</th><th>Interpretation</th><th>Unicode</th></tr>
    </thead>
    <tbody>
      <tr><td class="fixed">\\</td><td>Single backslash</td><td class="fixed">U+005C</td></tr>
      <tr><td class="fixed">\"</td><td>Double quote</td><td class="fixed">U+0022</td></tr>
      <tr><td class="fixed">\b</td><td>Backspace</td><td class="fixed">U+0008</td></tr>
      <tr><td class="fixed">\f</td><td>Form feed</td><td class="fixed">U+000C</td></tr>
      <tr><td class="fixed">\n</td><td>Newline</td><td class="fixed">U+000A</td></tr>
      <tr><td class="fixed">\r</td><td>Carriage return</td><td class="fixed">U+000D</td></tr>
      <tr><td class="fixed">\t</td><td>Horizontal tab</td><td class="fixed">U+0009</td></tr>
      <tr><td class="fixed">\v</td><td>Vertical tab</td><td class="fixed">U+000B</td></tr>
      <tr><td class="fixed">\0</td><td>NUL (ASCII 0)</td><td class="fixed">U+0000</td></tr>
      <tr><td class="fixed">\U+<i>hhhhh</i>;</td><td>Unicode character in hexadecimal</td><td class="fixed">U+<i>hhhhh</i></td></tr>
    </tbody>
  </table>
  For example, the following would print the Unicode character "<code>U+1F95A EGG</code>" followed by a newline:
  <pre class="code">print("\U+1f95a;\n");</pre>
  <h4>Object Literal</h4>
  Object literals are enclosed in curly braces:
  <div class="railroad">literal-object</div>
  For example:
  <pre class="code">var a = {
  "well-known": true,
  x: "hello",
  y: 123,
  z: [1, 2, 3]
};</pre>
  Double quotes are needed for the first propety because 'well-known' is not a valid property identifier (<a>identifiers</a>).
  The ellipsis <code>...</code> syntax allows you to copy all the properties from another object.
  Note that in
  <pre class="code">var a = { x: "hello", y: 123, z: [1, 2, 3] };
var b = a;
var c = { ...a };</pre>
  the resulting values of <code>b</code> and <code>c</code> are subtly different.
  This is beause <code>a</code> and <code>b</code> refer to the same object, whereas the properties of <code>a</code> are duplicated in the new object <code>c</code>:
  <pre class="code">c.y = 321; // Do not affect 'a.y'
b.y = 321; // Affects 'a.y' also</pre>
  Properties are assigned to the new object in the order they appear in the list.
  For example:
  <pre class="code">var a = { x: 1, y: 2, z: 3 };
var b = { ...a, y: 4 }; // 'b' equals '{ x: 1, y: 4, z: 3 }'
var c = { y: 4, ...a }; // 'c' equals '{ x: 1, y: 2, z: 3 }'</pre>
  Object literals may be empty to denote an object that has no (initial) properties:
  <pre class="code">var e = {};</pre>
  <h4>Array Literal</h4>
  Array literals are enclosed in square brackets:
  <div class="railroad">literal-array</div>
  For example:
  <pre class="code">var a = [
  true,     // Element 0, a Boolean
  "hello",  // Element 1, a string
  123,      // Element 2, an integer
  [1, 2, 3] // Element 4, another array
];</pre>
  Array elements may be <i>heterogeneous</i> (as in the case of <code>a</code> above) or <i>homogeneous</i> (all the elements have the same type):
  <pre class="code">int[] b = [1, 2, 3];</pre>
  The ellipsis <code>...</code> syntax allows you to copy all the elements from another array at that location:
  <pre class="code">var a = ["hello", 123, [1, 2, 3]];
var b = [true, ...a, 3.14159]; // Equals [true, "hello", 123, [1, 2, 3], 3.14159]</pre>
  It can be used to create a <i>shallow copy</i> of another array:
  <pre class="code">var c = [...a]; // Shallow copies 'a' into 'c'</pre>
  Array literals may be empty to denote an array that has no (initial) elements:
  <pre class="code">var e = [];</pre>
  <h4>Type Literal</h4>
  Type literals are used in type definitions (<a>type-definition</a>) and in type expressions (<a>type-expressions</a>) where they are preceded by the <code>type</code> keyword:
  <div class="railroad">literal-type</div>
  They are similar to object literals, except that the property values may be types and the ellipsis <code>...</code> syntax is not supported.
  Type literals make use of <i>well-known</i> properties names.
  See <a href="types.html">Type Schema</a> for more information [TODO].
  <h3>Value Expressions</h3>
  Value expressions (usually abbreviated to just "<i>expressions</i>") evaluate to values.
  Values have types; therefore expressions also have types.
  <div class="railroad">expression</div>
  <h4>Ternary Operator</h4>
  The ternary operator evaluates a Boolean expression and, depending on the result, returns the value of one of two expressions.
  For example, the following:
  <pre class="code">var w = x ? y : z;</pre>
  is analogous to
  <pre class="code">any? w;
if (x) {
  w = y;
} else {
  w = z;
}</pre>
  Note that expression <code>y</code> is only evaluated if <code>x</code> is true and expression <code>z</code> is only evaluated if <code>x</code> is false.
  The expression <code>x</code> must evaluate to a Boolean.
  The potential type of <code>w</code> is the union of the types of <code>y</code> and <code>z</code>.
  <h4>Binary Operator</h4>
  Binary operators take two operands: the left-hand side and the right-hand size.
  <div class="railroad">expression-binary</div>
  The binary operators are defined thus:
  <table>
    <thead>
      <tr><th>Precedence</th><th>Binary<br />Operator</th><th>Interpretation</th><th>Operand<br />Types</th><th>Result<br />Type</th></tr>
    </thead>
    <tbody>
      <tr><td>1 &mdash; lowest</td><td class="fixed">??</td><td>Null-coalescing</td><td class="fixed">L? R</td><td class="fixed">L|R</td></tr>
      <tr><td>2</td><td class="fixed">||</td><td>Logical OR</td><td class="fixed">bool</td><td class="fixed">bool</td></tr>
      <tr><td>3</td><td class="fixed">&&</td><td>Logical AND</td><td class="fixed">bool</td><td class="fixed">bool</td></tr>
      <tr><td>4</td><td class="fixed">|</td><td>Bitwise inclusive OR</td><td class="fixed">bool<br />int</td><td class="fixed">bool<br />int</td></tr>
      <tr><td>5</td><td class="fixed">^</td><td>Bitwise exclusive OR</td><td class="fixed">bool<br />int</td><td class="fixed">bool<br />int</td></tr>
      <tr><td>6</td><td class="fixed">&</td><td>Bitwise AND</td><td class="fixed">bool<br />int</td><td class="fixed">bool<br />int</td></tr>
      <tr><td>7</td><td class="fixed">==<br />!=</td><td>Equality<br />Inequality</td><td class="fixed">any?</td><td class="fixed">bool</td></tr>
      <tr><td>8</td><td class="fixed">&lt;<br />&gt;<br />&lt;=<br />&gt;=</td><td>Less than<br />Greater than<br />Less than or equal to<br />Greater than or equal to</td><td class="fixed">int<br />float</td><td class="fixed">bool</td></tr>
      <tr><td>9</td><td class="fixed">&lt;&lt;<br />&gt;&gt;<br />&gt;&gt;&gt;</td><td>Shift left<br />Shift right<br />Shift right unsigned</td><td class="fixed">int</td><td class="fixed">int</td></tr>
      <tr><td>10</td><td class="fixed">+<br />-</td><td>Add<br />Subtract</td><td class="fixed">int<br />float</td><td class="fixed">int<br />float</td></tr>
      <tr><td>11 &mdash; highest</td><td class="fixed">*<br />/<br />%</td><td>Multiply<br />Divide<br />Remainder</td><td class="fixed">int<br />float</td><td class="fixed">int<br />float</td></tr>
    </tbody>
  </table>
  This is the same precedence order as other "curly brace" programming languages.
  <h4>Unary Operator</h4>
  Unary operators take a single operand.
  In the <span class="egg">egg</span> programming language, unary operators always precede the operand:
  <div class="railroad">expression-unary</div>
  Therefore, unary operators do not need a precedence order, other than that they are applied <i>before</i> binary operators.
  <table>
    <thead>
      <tr><th>Unary<br />Operator</th><th>Interpretation</th><th>Operand<br />Type</th><th>Result<br />Type</th></tr>
    </thead>
    <tbody>
      <tr><td class="fixed">*</td><td>Pointer dereference</td><td class="fixed">T*</td><td class="fixed">T</td></tr>
      <tr><td class="fixed">-</td><td>Numeric negation</td><td class="fixed">int<br />float</td><td class="fixed">int<br />float</td></tr>
      <tr><td class="fixed">~</td><td>Bitwise NOT</td><td class="fixed">int</td><td class="fixed">int</td></tr>
      <tr><td class="fixed">!</td><td>Logical NOT</td><td class="fixed">bool</td><td class="fixed">bool</td></tr>
    </tbody>
  </table>
  Unlike many other programming languages, increment <code>++</code> and decrement <code>--</code> are statements; they do not yield values.
  See <a>increment-decrement-statement</a>.
  <h4>Primary Expression</h4>
  A primary expression is one of the following:
  <ul>
    <li>a variable identifier,</li>
    <li>a literal,</li>
    <li>a function expression,</li>
    <li>a lambda expression, or</li>
    <li>another expression inside parentheses <code>()</code>.</li>
  </ul>
  These may be followed by any number of indexing operations, property lookups or function calls:
  <div class="railroad">expression-primary</div>
  <h4>Function Expression</h4>
  Function expressions are like function definitions, but without a function name:
  <div class="railroad">expression-function</div>
  For example:
  <pre class="code">var func = int(int a, int b) { return a + b; };
print(func(2, 3), "\n"); // Prints 5
func = int(int a, int b) { return a - b; };
print(func(2, 3), "\n"); // Prints -1</pre>
  <h4>Lambda Expression</h4>
  Lambda expressions are like function expressions but are more concise because types are inferred.
  <div class="railroad">expression-lambda</div>
  For example:
  <pre class="code">int applyBinary(int(int a, int b) func, int x, int y) {
  return func(x, y);
}
var p = applyBinary((a, b) => { return a + b; }, 2, 3);
print(p, "\n"); // Prints 5
var q = applyBinary((a, b) => { return a - b; }, 2, 3);
print(q, "\n"); // Prints -1</pre>
  In the example above, because the bodies of the lambda expressions only contain <code>return</code> statements, we can use the shorter form:
  <pre class="code">var p = applyBinary((a, b) => a + b, 2, 3);
print(p, "\n"); // Prints 5
var q = applyBinary((a, b) => a - b, 2, 3);
print(q, "\n"); // Prints -1</pre>
  If there is only one parameter to the lambda, an even shorter form can be used:
  <pre class="code">int applyUnary(int(int a) func, int x) {
  return func(x);
}
var p = applyUnary(a => -a, 2);
print(p, "\n"); // Prints -2
var q = applyUnary(a => a * a, 2);
print(q, "\n"); // Prints 4</pre>
  Note that lambda expressions may only be used when the parameter types can be <i>trivially</i> inferred.
  At other times, the full function expression syntax must be used.
  <h3>Indexing</h3>
  An expression may be <i>indexed</i> using square brackets <code>[]</code>.
  The indexing expression may be of any type.
  Indexes for standard arrays are integers.
  By convention, array indices start at zero.
  <pre class="code">var arr = ["first", "second", "third", "fourth"];
print(arr[1], "\n"); // Prints "second"</pre>
  Indexes for standard objects are strings representing the property name:
  <pre class="code">var obj = {
  forename: "Charlie",
  surname: "Chaplin",
  year: 1889
};
print(obj["surname"], "\n"); // Prints "Chaplin"</pre>
  <h3>Properties</h3>
  Properties are named values associated with objects.
  Standard arrays have a read-only property named <code>length</code> which returns the number of elements in the array, as an integer:
  <pre class="code">var arr = ["a", "b", "c", "d"];
print(arr.length, "\n"); // Prints 4</pre>
  You can only access properties via the "dot" notation if those properties have names that conform to the identifier naming conventions (<a>identifiers</a>).
  <pre class="code">var obj = {
  forename: "Charlie",
  surname: "Chaplin",
  "year-of-birth": 1889
};
print(obj.forename, "\n"); // Prints "Charlie"
print(obj["surname"], "\n"); // Prints "Chaplin". Could also use 'obj.surname'
print(obj["year-of-birth"], "\n"); // Prints 1889. Cannot use "dot" notation</pre>
  <h3>Type Expressions</h3>
  Type expressions are unions of one or more types.
  Each item in the union is a primary type followed by zero or more suffixes.
  <div class="railroad">type-expression</div>
  Primary types are one of the following:
  <ul>
    <li>a parameterized generic type,</li>
    <li>a fundamental type,</li>
    <li>a type literal, or</li>
    <li>another type expression inside parentheses <code>()</code>.</li>
  </ul>
  That is
  <div class="railroad">type-expression-primary</div>
  Note that <code>null</code> is a <i>value</i> whereas <code>type null</code> is a <i>type</i>.
  <h4>Fundamental Type</h4>
  There are seven fundamental types:
  <table>
    <thead>
      <tr><th>Fundamental Type</th><th>Permissible Values</th><th>Inclusive Range</th></tr>
    </thead>
    <tbody>
      <tr><td class="fixed">void</td><td>None</td><td></td></tr>
      <tr><td class="fixed">bool</td><td><a href="https://en.wikipedia.org/wiki/Boolean_data_type">Boolean</a></td><td>Only <span class="fixed">false</span> or <span class="fixed">true</span></td></tr>
      <tr><td class="fixed">int</td><td><a href="https://en.wikipedia.org/wiki/64-bit_computing">Integers (64-bit)</a></td><td>-2<sup>63</sup> to 2<sup>63</sup>-1</td></tr>
      <tr><td class="fixed">float</td><td><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Floating-point numbers (IEEE double 64-bit)</a></td><td>About -10<sup>308</sup> to 10<sup>308</sup></td></tr>
      <tr><td class="fixed">string</td><td>Strings of zero or more <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> code points</td><td>Each code point: <span class="fixed">U+0</span> to <span class="fixed">U+10FFFF</span></td></tr>
      <tr><td class="fixed">object</td><td></td><td></td></tr>
      <tr><td class="fixed">type null</td><td>Null</td><td>Only <span class="fixed">null</span></td></tr>
    </tbody>
  </table>
  Note that <code>void</code> cannot be used as the type of a variable or function parameter, but may be used as the return type of a function:
  <pre class="code">void greet(string name) {
  print("hello ", name, "\n");
}</pre>
  In addition to the fundamental types, <code>any</code> is synonymous with <code>bool|int|float|string|object</code>:
  <pre class="code">void display(any value) {
  print("The value is ", value, "\n");
}</pre>
  <h4>Nullable Type</h4>
  By default, <span class="egg">egg</span> types do not permit <code>null</code> values.
  For example:
  <pre class="code">string name;
name = null; // Not permitted!</pre>
  To permit values to be <i>nullable</i>, a question mark <code>?</code> is appended to the type:
  <pre class="code">string? name;
name = null; // Permitted</pre>
  To clarify, the following two types are equivalent:
  <pre class="code">type NullableString1 = string?;
type NullableString2 = string|type null;</pre>
  This even extends to <code>any</code>; to permit <code>null</code> to be stored, use <code>any?</code>.
  <h4>Iterator Type</h4>
  Generator functions (<a>generator-function-definition</a>) are functions that return other functions known as "<i>iterators</i>".
  Iterators take no parameters and return either <code>void</code> or some type, say <code>T</code>.
  An iterator therefore looks like the following:
  <pre class="code">(T|void) someIterator() {
 // ...
}</pre>
  A generator function therefore looks like:
  <pre class="code">(T|void)() someGenerator(any someParameter1, any someParameter2) {
 // ...
}</pre>
  If a function takes an iterator as a parameter, it could look like this:
  <pre class="code">(T|void)() someFunction((T|void)() someInputIterator) {
 // ...
}</pre>
  To simplify the syntax, the <code>!</code> suffix can be applied to a type <code>T</code> to obtain the appropriate iterator:
  <pre class="code">T! someGenerator() {
 // ...
}

T! someFunction(T! someInputIterator) {
 // ...
}</pre>
  <h4>Pointer Type</h4>
  A pointer <i>points</i> to another value.
  More than one pointer can point to the same value.
  You can change the value of the pointer or the value the pointer points to.
  A pointer to a value of type <code>T</code> has a type <code>T*</code>.
  For example:
  <pre class="code">string comedian = "Laurel";
string* pointer = &comedian;   // 'pointer' now points to variable 'comedian'
*pointer = "Hardy";            // 'comedian' now contains "Hardy"
string swashbuckler = "Flynn";
pointer = &swashbuckler;       // 'pointer' now points to variable 'swashbuckler'</pre>
  Unlike some other languages, <span class="egg">egg</span> does <i>not</i> support pointer arithmetic.
  By default, pointers cannot be <code>null</code> unless their type explicitly uses the <code>?</code> suffix:
  <pre class="code">int i = 123;
int*? p = &i; // 'p' can point to an integer or be null
p = null;</pre>
  There is a subtle interaction between pointers and nullability:
  <table>
    <thead>
      <tr><th>Pointer Type</th><th>Interpretation</th></tr>
    </thead>
    <tbody>
      <tr><td class="fixed">T*</td><td>Can only point to values of type <span class="fixed">T</span></td></tr>
      <tr><td class="fixed">T*?</td><td>Can be <span class="fixed">null</span> or point to values of type <span class="fixed">T</span></td></tr>
      <tr><td class="fixed">T?*</td><td>Can only point to <span class="fixed">null</span> or values of type <span class="fixed">T</span></td></tr>
      <tr><td class="fixed">T?*?</td><td>Can be <span class="fixed">null</span>, point to <span class="fixed">null</span> or point to values of type <span class="fixed">T</span></td></tr>
    </tbody>
  </table>
  Pointer types are often used for function parameters to pass parameters by reference:
  <pre class="code">int totalPositives(float[] input, float* output) {
  int count = 0;
  *output = 0.0;
  for (var value : input) {
    if (value &gt; 0) {
      *output += value;
      ++count;
    }
  }
  return count;
}</pre>
  Pointers to pointers are valid.
  <h4>Indexed Type</h4>

  <h4>Generic Type</h4>
  The <span class="egg">egg</span> language supports simple <i>generic types</i>.
  These are defined in type definitions (<a>type-definition</a>) but instantiated by supplying the concrete types for the parameters:
  <pre class="code">type Dictionary&lt;K, V&gt; = {
  properties: {
    add: bool(K key, V value),
    remove: bool(K key),
    find: V?(K key)
  }
};
Dictionary&lt;int, string&gt; dict = createDictionary();
dict.add(8, "eight");</pre>
  The example above defines a dictionary generic type which takes two type parameters: the type of the dictionary key <code>K</code> and the type of the dictionary value <code>V</code>.
  The variable <code>dict</code> is then introduced as a dictionary with the keys being integers and the values being strings.
  <h3>Conditions</h3>
  TODO
  <div class="railroad">condition</div>
  <h3>Function Calls</h3>
  Function calls can either be statements or expressions.
  <h4>Function Call Statement</h4>
  A function with a return value of <code>void</code> can be invoked via a call statement:
  <div class="railroad">statement-call</div>
  TODO
  <div class="railroad">parameter-list</div>
  <h4>Function Call Expression</h4>
  A function that returns a non-<code>void</code> value, may be used as an expression.
  TODO
  <h3>Attributes</h3>
  TODO
  <div class="railroad">attribute</div>
  <h2><span class="egg">egg</span> Syntax Poster</h2>
  The syntax railroad diagrams above are available as a <a href="poster.html">single poster</a> suitable for printing at A3 size.
  <h1>Formal Syntax</h1>
  <h2>EBNF</h2>
  <div class="collapsible">
    <div>Syntax in <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">extended Backus-Naur form</a></div>
    <div id="ascii"></div>
  </div>
  <h2>Railroad</h2>
  <div class="collapsible">
    <div>Syntax in <a href="http://www.bottlecaps.de/rr/ui">Railroad Diagram Generator</a> format</div>
    <div id="bottlecaps" class="fixed"></div>
  </div>
  <footer>Copyright &copy; 2018-<span id="year">2019</span> <a href="http://chilliant.com">chilliant.com</a></footer>
  <script>
    egg.year("year");
    egg.diagram(document.getElementsByClassName("diagram"));
    egg.railroad(document.getElementsByClassName("railroad"));
    egg.prettify(document.getElementsByClassName("code"));
    egg.syntax("ascii");
    egg.syntax("bottlecaps");
    egg.toc("toc", document.getElementsByTagName("a"));
    egg.collapsible(document.getElementsByClassName("collapsible"));
  </script>
</body>
</html>
