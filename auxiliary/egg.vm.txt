/* EBNF of the Egg Virtual Machine specification */
/* For use in http://www.bottlecaps.de/rr/ui */
module ::= '(module' block ')' /* up to three arguments reserved */
attribute ::= '(attribute' literal-string attribute-parameter* ')'
attribute-parameter ::= expression | named
block ::= '(block' statement+ ')'
end ::= '(end)'
statement ::= block | statement-flow | statement-assert | statement-function | statement-generator | statement-declaration | statement-assign | statement-mutate | statement-nudge | statement-noop | statement-call
statement-flow ::= statement-if | statement-for | statement-foreach | statement-while | statement-do | statement-switch | statement-try | statement-break | statement-continue | statement-return | statement-yield | statement-throw
statement-if ::= '(if' condition block statement? ')' /* last must be 'if-statement' or 'block' */
statement-for ::= '(for' statement condition statement block ')'
statement-foreach ::= '(foreach' target expression block ')'
statement-while ::= '(while' condition block ')'
statement-do ::= '(do' expression block ')'
statement-switch ::= '(switch' expression statement-switch-clause+ ')'
statement-switch-clause ::= statement-switch-case | statement-switch-default
statement-switch-case ::= '(case' block literal-bool expression+ ')'
statement-switch-default ::= '(default' block literal-bool expression* ')' /* not necessarily last; may have expressions */
statement-try ::= '(try' statement-try-catch* statement-try-finally? ')'
statement-try-catch ::= '(catch' type identifier block ')'
statement-try-finally ::= '(finally' block ')'
statement-break ::= '(break)'
statement-continue ::= '(continue)'
statement-return ::= '(return' expression? ')'
statement-yield ::= '(yield' expression? ')'
statement-throw ::= '(throw' expression? ')'
statement-assert ::= '(assert' expression ')' /* attributes have location */
statement-function ::= '(function' type block identifier? ')' /* matches 'expression-function' */
statement-generator ::= '(generator' type block identifier? ')' /* matches 'expression-generator' */
statement-assign ::= '(assign' target expression ')'
statement-mutate ::= '(mutate' target operator-binary expression ')'
statement-nudge ::= statement-nudge-increment | statement-nudge-decrement
statement-nudge-increment ::= '(increment' target ')'
statement-nudge-decrement ::= '(decrement' target ')'
statement-call ::= '(call' expression expression-call-parameter* ')'
statement-noop ::= '(noop)'
condition ::= expression | guard
guard ::= '(guard' type identifier expression ')'
ellipsis ::= '(ellipsis' expression ')'
named ::= '(named' identifier expression ')'
meta ::= '(meta' expression identifier ')'
target ::= target-identifier | target-property | target-propertyq | target-index | target-pointee
target-identifier ::= '(identifier' identifier ')'
target-property ::= '(property' expression identifier ')'
target-propertyq ::= '(propertyq' expression identifier ')' /* for "object?.property" */
target-index ::= '(index' expression expression ')'
target-pointee ::= '(pointee' expression ')'
expression ::= expression-unary | expression-binary | expression-ternary | expression-function | expression-generator | expression-lambda | expression-call | literal | target | target-address | type | meta
expression-unary ::= '(unary' operator-unary expression ')'
expression-binary ::= '(binary' operator-binary expression expression ')'
expression-ternary ::= '(ternary' operator-ternary expression expression expression ')'
expression-function ::= '(function' type block identifier? ')'
expression-generator ::= '(generator' type block identifier? ')'
expression-lambda ::= '(lambda' block identifer* ')'
expression-call ::= '(call' expression expression-call-parameter* ')'
expression-call-parameter ::= expression | ellipsis | named
operator-unary ::= '-' | '~' | '!' | '&'
operator-binary ::= '!=' | '%' | '&' | '&&' | '*' | '+' | '-' | '/' | '<' | '<<' | '<=' | '==' | '>' | '>=' | '>>' | '>>>' | '??' | '^' | '|' | '||'
operator-ternary ::= '?:'
operator-compare ::= '!=' | '<' | '<=' | '==' | '>' | '>='
type ::= type-inferred | type-any | type-anyq | type-union | type-constrained
type-inferred ::= '(inferred)' /* alias for "var" */
type-any ::= '(any)' /* alias for "any" => '(union (bool) (int) (float) (string) (object) (type))' */
type-anyq ::= '(anyq)' /* alias for "any?" => '(union (null) (bool) (int) (float) (string) (object) (type))' */
type-union ::= '(union' type-constrained+ ')'
type-constrained ::= type-type | type-pointer | type-void | type-null | type-bool | type-int | type-float | type-string | type-object
type-type ::= '(type' type-constrained* ')'
type-pointer ::= '(pointer' type ')'
type-void ::= '(void)'
type-null ::= '(null)'
type-bool ::= '(bool' literal-bool? ')'
type-int ::= '(int' type-int-constraint* ')'
type-int-constraint ::= type-int-constraint-compare | type-int-constraint-maximum | type-int-constraint-choice | type-int-constraint-not
type-int-constraint-compare ::= '(compare' operator-compare literal-int ')'
type-int-constraint-choice ::= '(choice' literal-int+ ')'
type-int-constraint-not ::= '(not' type-int-constraint ')'
type-float ::= '(float' type-float-constraint* ')'
type-float-constraint ::= type-float-constraint-compare | type-float-constraint-choice | type-float-constraint-finite | type-float-constraint-not
type-float-constraint-compare ::= '(compare' operator-compare literal-float ')'
type-float-constraint-choice ::= '(choice' literal-float+ ')'
type-float-constraint-finite ::= '(finite)'
type-float-constraint-not ::= '(not' type-float-constraint ')'
type-string ::= '(string' type-string-constraint* ')'
type-string-constraint ::= type-string-constraint-length | type-string-constraint-choice | type-string-constraint-regex | type-string-constraint-not
type-string-constraint-length ::= '(length' type-int-constraint+ ')'
type-string-constraint-choice ::= '(choice' literal-string+ ')'
type-string-constraint-regex ::= '(regex' literal-string ')'
type-string-constraint-not ::= '(not' type-string-constraint ')'
type-object ::= '(object' type-object-constraint* ')'
type-object-constraint ::= type-object-constraint-callable | type-object-constraint-indexable | type-object-constraint-iterable | type-object-constraint-properties
type-object-constraint-callable ::= '(callable' type type-object-constraint-callable-parameter* ')'
type-object-constraint-callable-parameter ::= type-object-constraint-callable-parameter-required | type-object-constraint-callable-parameter-optional | type-object-constraint-callable-parameter-byname | type-object-constraint-callable-parameter-varargs
type-object-constraint-callable-parameter-required ::= '(required' type identifier? ')'
type-object-constraint-callable-parameter-optional ::= '(optional' type identifier? ')'
type-object-constraint-callable-parameter-byname ::= '(byname' type identifier ')'
type-object-constraint-callable-parameter-varargs ::= '(varargs' type identifier type-int-constraint* ')'
type-object-constraint-indexable ::= '(indexable' type type literal-bool literal-bool ')' /* domain, range, readable, writable */
type-object-constraint-iterable ::= '(iterable' type ')'
type-object-constraint-properties ::= type-object-constraint-properties-has | type-object-constraint-properties-hasq | type-object-constraint-properties-extensible
type-object-constraint-properties-has ::= '(has' type identifier ')'
type-object-constraint-properties-hasq ::= '(hasq' type identifier ')'
type-object-constraint-properties-extensible ::= '(extensible' type type-string-constraint* ')'
identifier ::= literal-string
literal ::= literal-null | literal-bool | literal-int | literal-float | literal-string | literal-object | literal-array
literal-null ::= '(null)'
literal-bool ::= literal-bool-false | literal-bool-true
literal-bool-false ::= '(false)'
literal-bool-true ::= '(true)'
literal-int ::= '(ivalue' operand ')'
literal-float ::= '(fvalue' operand ')'
literal-string ::= '(svalue' operand ')'
literal-object ::= '(ovalue' literal-object-element* ')'
literal-object-element ::= named | ellipsis
literal-array ::= '(avalue' literal-array-element* ')'
literal-array-element ::= expression | ellipsis
operand ::= [type://unsigned-integer]
